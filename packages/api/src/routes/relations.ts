import { Hono } from 'hono';
import { getStorage } from '../utils/storage.js';

const app = new Hono();

/**
 * GET /api/relations/:memoryId?depth=2
 * 获取记忆关系链（树形结构）
 */
app.get('/:memoryId', async (c) => {
  const memoryId = c.req.param('memoryId');
  const depth = parseInt(c.req.query('depth') || '2', 10);

  const storage = getStorage();

  const result = await storage.getRelations({
    memoryId,
    depth,
  });

  return c.json({
    success: true,
    data: result,
  });
});

/**
 * GET /api/relations/:memoryId/details
 * 获取记忆的关联详情（平铺列表，包含置信度和原因）
 */
app.get('/:memoryId/details', async (c) => {
  const memoryId = c.req.param('memoryId');
  const includeAutoGenerated = c.req.query('includeAutoGenerated') !== 'false';
  const type = c.req.query('type') as 'relatedTo' | 'replaces' | 'impacts' | undefined;

  const storage = getStorage();

  if (!storage.getMemoryRelations) {
    return c.json({
      success: false,
      error: '当前存储不支持关联详情功能',
    }, 501);
  }

  const relations = await storage.getMemoryRelations(memoryId, {
    includeAutoGenerated,
    type,
  });

  // 获取关联记忆的详细信息
  const relatedMemories = await Promise.all(
    relations.map(async (rel) => {
      const memory = await storage.getById(rel.targetId);
      return {
        ...rel,
        targetMemory: memory ? {
          id: memory.meta?.id,
          summary: memory.content.summary,
          type: memory.meta?.type,
          projectId: memory.meta?.projectId,
          tags: memory.meta?.tags,
          timestamp: memory.meta?.timestamp,
        } : null,
      };
    })
  );

  return c.json({
    success: true,
    data: {
      memoryId,
      relations: relatedMemories,
      total: relatedMemories.length,
      autoGeneratedCount: relatedMemories.filter(r => r.isAutoGenerated).length,
    },
  });
});

/**
 * DELETE /api/relations/:sourceId/:targetId
 * 删除记忆关联
 */
app.delete('/:sourceId/:targetId', async (c) => {
  const sourceId = c.req.param('sourceId');
  const targetId = c.req.param('targetId');
  const type = c.req.query('type');

  const storage = getStorage();

  if (!storage.deleteRelation) {
    return c.json({
      success: false,
      error: '当前存储不支持删除关联功能',
    }, 501);
  }

  const result = await storage.deleteRelation(sourceId, targetId, type);

  return c.json({
    success: result.success,
    message: result.success ? '关联已删除' : '删除失败',
  });
});

export const relationsRoutes = app;
