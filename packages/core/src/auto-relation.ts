/**
 * 自动关联模块
 * 存储记忆时自动分析并建立与已有记忆的关联关系
 */

import { extractKeywords, jaccardSimilarity, getKeywordIntersection } from './keywords.js';
import type { Memory } from './memory.js';
import type { MemoryType } from './types.js';

/**
 * 相似度计算结果
 */
export interface SimilarityResult {
  /** 综合相似度分数 0-1 */
  score: number;
  /** 关联原因说明 */
  reason: string;
  /** 各维度得分明细 */
  details: {
    keywordScore: number;
    tagScore: number;
    typeScore: number;
    timeScore: number;
  };
}

/**
 * 候选关联记忆
 */
export interface RelationCandidate {
  /** 记忆对象 */
  memory: Memory;
  /** 相似度信息 */
  similarity: SimilarityResult;
}

/**
 * 自动关联配置
 */
export interface AutoRelationConfig {
  /** 关联阈值（0-1，默认 0.3） */
  threshold?: number;
  /** 最大关联数量（默认 10） */
  maxRelations?: number;
  /** 是否启用跨项目关联（默认 true） */
  crossProject?: boolean;
  /** 时间窗口（天数，默认 30） */
  timeWindowDays?: number;
}

// 默认配置
const DEFAULT_CONFIG: Required<AutoRelationConfig> = {
  threshold: 0.3,
  maxRelations: 10,
  crossProject: true,
  timeWindowDays: 30,
};

/**
 * 类型关联权重矩阵
 * 某些类型之间更可能有关联
 */
const TYPE_RELATION_MATRIX: Record<string, Record<string, number>> = {
  decision: { solution: 0.8, config: 0.7, code: 0.6, error: 0.5, session: 0.4, decision: 0.9 },
  solution: { error: 0.9, decision: 0.8, code: 0.7, config: 0.6, session: 0.4, solution: 0.8 },
  config: { code: 0.8, decision: 0.7, error: 0.6, solution: 0.5, session: 0.4, config: 0.9 },
  code: { config: 0.8, error: 0.7, solution: 0.6, decision: 0.5, session: 0.4, code: 0.8 },
  error: { solution: 0.9, code: 0.7, config: 0.6, decision: 0.5, session: 0.4, error: 0.7 },
  session: { decision: 0.6, solution: 0.5, config: 0.4, code: 0.4, error: 0.4, session: 0.5 },
};

/**
 * 获取类型关联分数
 */
function getTypeRelationScore(type1: string, type2: string): number {
  return TYPE_RELATION_MATRIX[type1]?.[type2] ?? 0.5;
}

/**
 * 计算时间接近度分数
 * 24小时内得分最高，随时间递减
 */
function getTimeProximityScore(time1: string | Date, time2: string | Date): number {
  const date1 = new Date(time1);
  const date2 = new Date(time2);
  const diffHours = Math.abs(date1.getTime() - date2.getTime()) / (1000 * 60 * 60);

  if (diffHours <= 24) return 1.0;
  if (diffHours <= 72) return 0.8;
  if (diffHours <= 168) return 0.6; // 一周
  if (diffHours <= 720) return 0.4; // 一个月
  return 0.2;
}

/**
 * 计算两条记忆的相似度
 */
export function calculateSimilarity(
  memory1: Memory,
  memory2: Memory
): SimilarityResult {
  const reasons: string[] = [];

  // 1. 关键词相似度 (权重 0.4)
  const keywords1 = memory1.searchable?.keywords || [];
  const keywords2 = memory2.searchable?.keywords || [];
  const keywordScore = jaccardSimilarity(keywords1, keywords2);

  if (keywordScore > 0.2) {
    const overlap = getKeywordIntersection(keywords1, keywords2);
    if (overlap.length > 0) {
      reasons.push(`关键词重叠: ${overlap.slice(0, 5).join(', ')}`);
    }
  }

  // 2. 标签相似度 (权重 0.3)
  const tags1 = memory1.meta?.tags || [];
  const tags2 = memory2.meta?.tags || [];
  const tagScore = jaccardSimilarity(tags1, tags2);

  if (tagScore > 0) {
    const tagOverlap = getKeywordIntersection(tags1, tags2);
    if (tagOverlap.length > 0) {
      reasons.push(`标签重叠: ${tagOverlap.join(', ')}`);
    }
  }

  // 3. 类型关联度 (权重 0.2)
  const type1 = memory1.meta?.type || 'code';
  const type2 = memory2.meta?.type || 'code';
  const typeScore = getTypeRelationScore(type1, type2);

  // 4. 时间接近度 (权重 0.1)
  const timeScore = getTimeProximityScore(
    memory1.createdAt || memory1.meta?.timestamp || new Date(),
    memory2.createdAt || memory2.meta?.timestamp || new Date()
  );

  // 综合得分
  const score =
    keywordScore * 0.4 +
    tagScore * 0.3 +
    typeScore * 0.2 +
    timeScore * 0.1;

  return {
    score,
    reason: reasons.length > 0 ? reasons.join('; ') : '综合相似',
    details: {
      keywordScore,
      tagScore,
      typeScore,
      timeScore,
    },
  };
}

/**
 * 从候选记忆中找出相关记忆
 */
export function findRelatedMemories(
  newMemory: Memory,
  candidates: Memory[],
  config: AutoRelationConfig = {}
): RelationCandidate[] {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  const results: RelationCandidate[] = [];

  for (const candidate of candidates) {
    // 跳过自身
    if (candidate.meta?.id === newMemory.meta?.id) continue;

    // 计算相似度
    const similarity = calculateSimilarity(newMemory, candidate);

    // 超过阈值则加入结果
    if (similarity.score >= cfg.threshold) {
      results.push({ memory: candidate, similarity });
    }
  }

  // 按相似度排序，取前 N 个
  return results
    .sort((a, b) => b.similarity.score - a.similarity.score)
    .slice(0, cfg.maxRelations);
}

/**
 * 记忆关系数据结构（用于存储到数据库）
 */
export interface MemoryRelationData {
  sourceId: string;
  targetId: string;
  type: 'relatedTo' | 'replaces' | 'impacts';
  confidence: number;
  isAutoGenerated: boolean;
  reason: string;
}

/**
 * 生成自动关联关系数据
 */
export function generateAutoRelations(
  newMemoryId: string,
  relatedCandidates: RelationCandidate[]
): MemoryRelationData[] {
  return relatedCandidates.map(candidate => ({
    sourceId: newMemoryId,
    targetId: candidate.memory.meta?.id || '',
    type: 'relatedTo' as const,
    confidence: candidate.similarity.score,
    isAutoGenerated: true,
    reason: candidate.similarity.reason,
  }));
}

/**
 * 项目组配置
 */
export interface ProjectGroupConfig {
  /** 项目组名称 */
  name: string;
  /** 包含的项目列表 */
  projects: string[];
}

/**
 * 根据项目名推断项目组
 * 支持常见命名模式：xxx-backend, xxx-frontend, xxx-api, xxx-web 等
 */
export function inferProjectGroup(projectId: string): string | null {
  // 常见后缀模式
  const suffixPatterns = [
    /-backend$/i,
    /-frontend$/i,
    /-api$/i,
    /-web$/i,
    /-app$/i,
    /-admin$/i,
    /-client$/i,
    /-server$/i,
    /-service$/i,
    /-shared$/i,
    /-common$/i,
    /-core$/i,
  ];

  for (const pattern of suffixPatterns) {
    if (pattern.test(projectId)) {
      return projectId.replace(pattern, '');
    }
  }

  return null;
}

/**
 * 检查两个项目是否在同一项目组
 */
export function isSameProjectGroup(
  project1: string,
  project2: string,
  groups: ProjectGroupConfig[]
): boolean {
  // 1. 直接匹配
  if (project1 === project2) return true;

  // 2. 检查配置的项目组
  for (const group of groups) {
    if (group.projects.includes(project1) && group.projects.includes(project2)) {
      return true;
    }
  }

  // 3. 推断项目组
  const group1 = inferProjectGroup(project1);
  const group2 = inferProjectGroup(project2);

  if (group1 && group2 && group1 === group2) {
    return true;
  }

  return false;
}

/**
 * 获取项目组中的所有项目
 */
export function getProjectGroupMembers(
  projectId: string,
  groups: ProjectGroupConfig[]
): string[] {
  // 1. 从配置中查找
  for (const group of groups) {
    if (group.projects.includes(projectId)) {
      return group.projects;
    }
  }

  // 2. 返回单个项目
  return [projectId];
}
