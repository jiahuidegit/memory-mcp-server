import { PrismaClient, Prisma } from '@prisma/client';
import { nanoid } from 'nanoid';
import {
  type IStorage,
  type SearchFilters,
  type SearchResult,
  type TimelineOptions,
  type TimelineResult,
  type TimelineEntry,
  type RelationsOptions,
  type RelationNode,
  MemoryType,
  SearchStrategy,
  type Memory,
  type DecisionContext,
  type SolutionContext,
  type SessionContext,
  type MemoryRelationData,
  type ProjectGroupConfig,
  // 自动关联相关
  findRelatedMemories,
  generateAutoRelations,
} from '@emp/core';
import { LRUCache } from './cache.js';

/**
 * PostgreSQL存储实现（云版）
 * 使用Prisma ORM + PostgreSQL全文搜索
 */
export class PostgreSQLStorage implements IStorage {
  private prisma: PrismaClient;
  private cache: LRUCache | null;

  constructor(databaseUrl?: string, options?: { enableCache?: boolean; cacheSize?: number }) {
    this.prisma = new PrismaClient({
      datasources: databaseUrl
        ? {
            db: { url: databaseUrl },
          }
        : undefined,
    });

    // 初始化缓存（默认启用，容量100）
    this.cache = options?.enableCache !== false ? new LRUCache(options?.cacheSize || 100) : null;
  }

  /**
   * 通用存储方法
   */
  async store(params: {
    content: string;
    data: Record<string, unknown>;
    rawContext: Record<string, unknown>;
    projectId: string;
    type?: MemoryType;
    tags?: string[];
    sessionId?: string;
    relations?: {
      replaces?: string[];
      relatedTo?: string[];
      impacts?: string[];
      derivedFrom?: string;
    };
  }): Promise<{ id: string; success: boolean }> {
    const id = `mem_${nanoid()}`;
    const timestamp = new Date();
    const memoryType = params.type || MemoryType.CODE;

    await this.prisma.memory.create({
      data: {
        id,
        projectId: params.projectId,
        sessionId: params.sessionId || null,
        timestamp,
        type: memoryType,
        tags: params.tags || [],
        summary: params.content,
        // data 存储关键结构化数据（精简版），context 存储完整原始数据（完整版）
        data: params.data as any,
        replaces: params.relations?.replaces || [],
        relatedTo: params.relations?.relatedTo || [],
        impacts: params.relations?.impacts || [],
        derivedFrom: params.relations?.derivedFrom || null,
        context: params.rawContext as any,
        keywords: params.tags || [],
        fullText: params.content,
      },
    });

    // 同步写入 MemoryRelation 表（手动指定的关系）
    if (params.relations) {
      const relationRecords: { sourceId: string; targetId: string; type: string; isAutoGenerated: boolean }[] = [];

      if (params.relations.relatedTo) {
        for (const targetId of params.relations.relatedTo) {
          relationRecords.push({ sourceId: id, targetId, type: 'relatedTo', isAutoGenerated: false });
        }
      }
      if (params.relations.replaces) {
        for (const targetId of params.relations.replaces) {
          relationRecords.push({ sourceId: id, targetId, type: 'replaces', isAutoGenerated: false });
        }
      }
      if (params.relations.impacts) {
        for (const targetId of params.relations.impacts) {
          relationRecords.push({ sourceId: id, targetId, type: 'impacts', isAutoGenerated: false });
        }
      }
      if (params.relations.derivedFrom) {
        relationRecords.push({ sourceId: id, targetId: params.relations.derivedFrom, type: 'derivedFrom', isAutoGenerated: false });
      }

      if (relationRecords.length > 0) {
        await this.prisma.memoryRelation.createMany({
          data: relationRecords,
          skipDuplicates: true,
        });
      }
    }

    // 失效相关缓存
    if (this.cache) {
      this.cache.invalidateProject(params.projectId);
    }

    // 自动关联：存储后自动查找相关记忆并建立关联
    await this.autoRelate(id, params.projectId, params.tags || []);

    return { id, success: true };
  }

  /**
   * 存储决策记忆
   */
  async storeDecision(
    params: DecisionContext & {
      projectId: string;
      tags?: string[];
      sessionId?: string;
      relations?: {
        replaces?: string[];
        relatedTo?: string[];
        impacts?: string[];
        derivedFrom?: string;
      };
    }
  ): Promise<{ id: string; success: boolean }> {
    const id = `mem_${nanoid()}`;
    const timestamp = new Date();
    const summary = `[决策] ${params.question}`;
    const fullText = `${params.question} ${params.options.map((o) => o.name).join(' ')} ${params.reason}`;
    const keywords = [...(params.tags || []), ...params.options.map((o) => o.name), params.chosen];

    await this.prisma.memory.create({
      data: {
        id,
        projectId: params.projectId,
        sessionId: params.sessionId || null,
        timestamp,
        type: MemoryType.DECISION,
        tags: params.tags || [],
        summary,
        data: {},
        replaces: params.relations?.replaces || [],
        relatedTo: params.relations?.relatedTo || [],
        impacts: params.relations?.impacts || [],
        derivedFrom: params.relations?.derivedFrom || null,
        context: {
          question: params.question,
          analysis: params.analysis,
          options: params.options,
          chosen: params.chosen,
          reason: params.reason,
        } as any,
        keywords,
        fullText,
      },
    });

    // 同步写入 MemoryRelation 表（手动指定的关系）
    if (params.relations) {
      const relationRecords: { sourceId: string; targetId: string; type: string; isAutoGenerated: boolean }[] = [];

      if (params.relations.relatedTo) {
        for (const targetId of params.relations.relatedTo) {
          relationRecords.push({ sourceId: id, targetId, type: 'relatedTo', isAutoGenerated: false });
        }
      }
      if (params.relations.replaces) {
        for (const targetId of params.relations.replaces) {
          relationRecords.push({ sourceId: id, targetId, type: 'replaces', isAutoGenerated: false });
        }
      }
      if (params.relations.impacts) {
        for (const targetId of params.relations.impacts) {
          relationRecords.push({ sourceId: id, targetId, type: 'impacts', isAutoGenerated: false });
        }
      }
      if (params.relations.derivedFrom) {
        relationRecords.push({ sourceId: id, targetId: params.relations.derivedFrom, type: 'derivedFrom', isAutoGenerated: false });
      }

      if (relationRecords.length > 0) {
        await this.prisma.memoryRelation.createMany({
          data: relationRecords,
          skipDuplicates: true,
        });
      }
    }

    // 失效相关缓存
    if (this.cache) {
      this.cache.invalidateProject(params.projectId);
    }

    // 自动关联：存储后自动查找相关记忆并建立关联
    await this.autoRelate(id, params.projectId, keywords);

    return { id, success: true };
  }

  /**
   * 存储解决方案记忆
   */
  async storeSolution(
    params: SolutionContext & {
      projectId: string;
      tags?: string[];
      sessionId?: string;
      artifacts?: Record<string, string>;
      relations?: {
        replaces?: string[];
        relatedTo?: string[];
        impacts?: string[];
        derivedFrom?: string;
      };
    }
  ): Promise<{ id: string; success: boolean }> {
    const id = `mem_${nanoid()}`;
    const timestamp = new Date();
    const summary = `[方案] ${params.problem}`;
    const fullText = `${params.problem} ${params.rootCause} ${params.solution} ${params.prevention || ''} ${params.relatedIssues?.join(' ') || ''}`;
    const keywords = [...(params.tags || []), ...(params.relatedIssues || [])];

    await this.prisma.memory.create({
      data: {
        id,
        projectId: params.projectId,
        sessionId: params.sessionId || null,
        timestamp,
        type: MemoryType.SOLUTION,
        tags: params.tags || [],
        summary,
        data: (params.artifacts || {}) as any,
        replaces: params.relations?.replaces || [],
        relatedTo: params.relations?.relatedTo || [],
        impacts: params.relations?.impacts || [],
        derivedFrom: params.relations?.derivedFrom || null,
        context: {
          problem: params.problem,
          rootCause: params.rootCause,
          solution: params.solution,
          prevention: params.prevention,
          relatedIssues: params.relatedIssues,
        } as any,
        keywords,
        fullText,
      },
    });

    // 同步写入 MemoryRelation 表（手动指定的关系）
    if (params.relations) {
      const relationRecords: { sourceId: string; targetId: string; type: string; isAutoGenerated: boolean }[] = [];

      if (params.relations.relatedTo) {
        for (const targetId of params.relations.relatedTo) {
          relationRecords.push({ sourceId: id, targetId, type: 'relatedTo', isAutoGenerated: false });
        }
      }
      if (params.relations.replaces) {
        for (const targetId of params.relations.replaces) {
          relationRecords.push({ sourceId: id, targetId, type: 'replaces', isAutoGenerated: false });
        }
      }
      if (params.relations.impacts) {
        for (const targetId of params.relations.impacts) {
          relationRecords.push({ sourceId: id, targetId, type: 'impacts', isAutoGenerated: false });
        }
      }
      if (params.relations.derivedFrom) {
        relationRecords.push({ sourceId: id, targetId: params.relations.derivedFrom, type: 'derivedFrom', isAutoGenerated: false });
      }

      if (relationRecords.length > 0) {
        await this.prisma.memoryRelation.createMany({
          data: relationRecords,
          skipDuplicates: true,
        });
      }
    }

    // 失效相关缓存
    if (this.cache) {
      this.cache.invalidateProject(params.projectId);
    }

    // 自动关联：存储后自动查找相关记忆并建立关联
    await this.autoRelate(id, params.projectId, keywords);

    return { id, success: true };
  }

  /**
   * 存储会话记忆
   */
  async storeSession(
    params: SessionContext & {
      projectId: string;
      sessionId?: string;
      relations?: {
        replaces?: string[];
        relatedTo?: string[];
        impacts?: string[];
        derivedFrom?: string;
      };
    }
  ): Promise<{ id: string; success: boolean }> {
    const id = `mem_${nanoid()}`;
    const timestamp = new Date();
    const summary = `[会话] ${params.summary}`;
    const fullText = `${params.summary} ${params.decisions?.join(' ') || ''} ${params.unfinishedTasks?.join(' ') || ''} ${params.nextSteps?.join(' ') || ''}`;
    const keywords = [...(params.decisions || []), ...(params.unfinishedTasks || [])];

    await this.prisma.memory.create({
      data: {
        id,
        projectId: params.projectId,
        sessionId: params.sessionId || id,
        timestamp,
        type: MemoryType.SESSION,
        tags: [],
        summary,
        data: {},
        replaces: params.relations?.replaces || [],
        relatedTo: params.relations?.relatedTo || [],
        impacts: params.relations?.impacts || [],
        derivedFrom: params.relations?.derivedFrom || null,
        context: {
          summary: params.summary,
          decisions: params.decisions,
          unfinishedTasks: params.unfinishedTasks,
          nextSteps: params.nextSteps,
        } as any,
        keywords,
        fullText,
      },
    });

    // 同步写入 MemoryRelation 表（手动指定的关系）
    if (params.relations) {
      const relationRecords: { sourceId: string; targetId: string; type: string; isAutoGenerated: boolean }[] = [];

      if (params.relations.relatedTo) {
        for (const targetId of params.relations.relatedTo) {
          relationRecords.push({ sourceId: id, targetId, type: 'relatedTo', isAutoGenerated: false });
        }
      }
      if (params.relations.replaces) {
        for (const targetId of params.relations.replaces) {
          relationRecords.push({ sourceId: id, targetId, type: 'replaces', isAutoGenerated: false });
        }
      }
      if (params.relations.impacts) {
        for (const targetId of params.relations.impacts) {
          relationRecords.push({ sourceId: id, targetId, type: 'impacts', isAutoGenerated: false });
        }
      }
      if (params.relations.derivedFrom) {
        relationRecords.push({ sourceId: id, targetId: params.relations.derivedFrom, type: 'derivedFrom', isAutoGenerated: false });
      }

      if (relationRecords.length > 0) {
        await this.prisma.memoryRelation.createMany({
          data: relationRecords,
          skipDuplicates: true,
        });
      }
    }

    // 失效相关缓存
    if (this.cache) {
      this.cache.invalidateProject(params.projectId);
    }

    // 自动关联：存储后自动查找相关记忆并建立关联
    await this.autoRelate(id, params.projectId, keywords);

    return { id, success: true };
  }

  /**
   * 检索记忆（新算法：多维度搜索 + 智能降级 + 关系链融合）
   *
   * 核心功能：
   * 1. 多维度搜索：projectId/summary/fullText/tags/keywords
   * 2. 智能降级：无结果时自动放宽条件
   * 3. 关系链融合：自动扩展关联记忆
   */
  async recall(filters: SearchFilters): Promise<SearchResult> {
    const startTime = Date.now();

    // 检查缓存
    if (this.cache) {
      const cacheKey = LRUCache.generateKey(filters);
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return cached;
      }
    }

    const limit = filters.limit || 10;
    const offset = filters.offset || 0;
    const expandRelations = filters.expandRelations !== false; // 默认开启
    const relationDepth = filters.relationDepth || 1;

    let dbStartTime = Date.now();

    // 执行多维度搜索
    const searchResult = await this.multiDimensionSearch(filters, limit, offset);
    let results = searchResult.memories;
    let total = searchResult.total;

    // 智能降级：如果没有结果且有查询条件，尝试放宽搜索
    if (results.length === 0 && filters.query) {
      // 降级1：只按 projectId 返回最近记忆
      if (filters.projectId || (filters.projectIds && filters.projectIds.length > 0)) {
        const degradedResult = await this.multiDimensionSearch(
          { ...filters, query: undefined },
          limit,
          offset
        );
        results = degradedResult.memories;
        total = degradedResult.total;
      }

      // 降级2：全局搜索（移除 projectId 限制）
      if (results.length === 0) {
        const globalResult = await this.multiDimensionSearch(
          { ...filters, projectId: undefined, projectIds: undefined },
          limit,
          offset
        );
        results = globalResult.memories;
        total = globalResult.total;
      }
    }

    // 关系链融合：扩展关联记忆
    let relatedMemories: Memory[] | undefined;
    if (expandRelations && results.length > 0) {
      relatedMemories = await this.expandRelatedMemories(results, relationDepth);
    }

    const dbEndTime = Date.now();
    const took = Date.now() - startTime;
    const dbTime = dbEndTime - dbStartTime;

    const result: SearchResult = {
      memories: results,
      relatedMemories,
      total,
      strategy: SearchStrategy.FULLTEXT,
      took,
      metrics: {
        dbTime,
        parseTime: Math.max(0, took - dbTime),
        cacheHit: false,
      },
    };

    // 写入缓存
    if (this.cache) {
      const cacheKey = LRUCache.generateKey(filters);
      this.cache.set(cacheKey, result);
    }

    return result;
  }

  /**
   * 扩展关联记忆
   *
   * 从 MemoryRelation 表和 Memory 内嵌字段两处获取关联记忆
   * 自动获取关联的记忆，去重后返回
   */
  private async expandRelatedMemories(
    memories: Memory[],
    depth: number = 1
  ): Promise<Memory[]> {
    if (depth <= 0 || memories.length === 0) {
      return [];
    }

    // 收集所有关联 ID（去重）
    const relatedIds = new Set<string>();
    const processedIds = new Set<string>(memories.map(m => m.meta.id));
    const memoryIds = memories.map(m => m.meta.id);

    // 1. 从 MemoryRelation 表获取关系
    const relations = await this.prisma.memoryRelation.findMany({
      where: {
        OR: [
          { sourceId: { in: memoryIds } },
          { targetId: { in: memoryIds } },
        ],
      },
    });

    for (const rel of relations) {
      if (memoryIds.includes(rel.sourceId)) {
        relatedIds.add(rel.targetId);
      }
      if (memoryIds.includes(rel.targetId)) {
        relatedIds.add(rel.sourceId);
      }
    }

    // 2. 同时检查 Memory 内嵌字段（兼容手动指定的关系）
    for (const memory of memories) {
      const { relations } = memory;
      if (!relations) continue;

      relations.relatedTo?.forEach(id => relatedIds.add(id));
      relations.replaces?.forEach(id => relatedIds.add(id));
      relations.impacts?.forEach(id => relatedIds.add(id));
      if (relations.derivedFrom) relatedIds.add(relations.derivedFrom);
    }

    // 过滤掉已经在主结果中的记忆
    const idsToFetch = Array.from(relatedIds).filter(id => !processedIds.has(id));

    if (idsToFetch.length === 0) {
      return [];
    }

    // 批量获取关联记忆
    const relatedRows = await this.prisma.memory.findMany({
      where: { id: { in: idsToFetch } },
      orderBy: { timestamp: 'desc' },
    });

    const relatedMemories = relatedRows.map(this.rowToMemory);

    // 递归扩展（如果需要更深层次）
    if (depth > 1 && relatedMemories.length > 0) {
      const deeperRelated = await this.expandRelatedMemories(relatedMemories, depth - 1);
      // 合并并去重
      const allRelated = [...relatedMemories];
      const existingIds = new Set(allRelated.map(m => m.meta.id));
      for (const m of deeperRelated) {
        if (!existingIds.has(m.meta.id) && !processedIds.has(m.meta.id)) {
          allRelated.push(m);
          existingIds.add(m.meta.id);
        }
      }
      return allRelated;
    }

    return relatedMemories;
  }

  /**
   * 多维度搜索（核心算法）
   * 搜索范围：projectId、summary、fullText、tags、keywords
   */
  private async multiDimensionSearch(
    filters: SearchFilters,
    limit: number,
    offset: number
  ): Promise<{ memories: Memory[]; total: number }> {
    const where: Prisma.MemoryWhereInput = {};
    const andConditions: Prisma.MemoryWhereInput[] = [];

    // 1. 项目过滤（支持单个或多个）
    if (filters.projectIds && filters.projectIds.length > 0) {
      andConditions.push({ projectId: { in: filters.projectIds } });
    } else if (filters.projectId) {
      andConditions.push({ projectId: filters.projectId });
    }

    // 2. 类型过滤
    if (filters.type) {
      andConditions.push({ type: filters.type });
    }

    // 3. 会话过滤
    if (filters.sessionId) {
      andConditions.push({ sessionId: filters.sessionId });
    }

    // 4. 标签过滤（精确匹配）
    if (filters.tags && filters.tags.length > 0) {
      andConditions.push({ tags: { hasSome: filters.tags } });
    }

    // 5. 多维度关键词搜索
    if (filters.query && filters.query.trim() !== '') {
      const keywords = filters.query.split(/\s+/).filter(k => k.length > 0);

      if (keywords.length > 0) {
        // 构建多维度 OR 条件：任一关键词匹配任一字段
        const keywordConditions: Prisma.MemoryWhereInput[] = keywords.flatMap(keyword => [
          // 搜索 projectId
          { projectId: { contains: keyword, mode: 'insensitive' as const } },
          // 搜索 summary
          { summary: { contains: keyword, mode: 'insensitive' as const } },
          // 搜索 fullText
          { fullText: { contains: keyword, mode: 'insensitive' as const } },
          // 搜索 tags 数组
          { tags: { hasSome: [keyword] } },
          // 搜索 keywords 数组
          { keywords: { hasSome: [keyword] } },
        ]);

        andConditions.push({ OR: keywordConditions });
      }
    }

    // 组合所有条件
    if (andConditions.length > 0) {
      where.AND = andConditions;
    }

    // 并行执行查询和计数
    const [rows, total] = await Promise.all([
      this.prisma.memory.findMany({
        where,
        orderBy: { timestamp: 'desc' },
        take: limit,
        skip: offset,
      }),
      this.prisma.memory.count({ where }),
    ]);

    return { memories: rows.map(this.rowToMemory), total };
  }

  /**
   * L1: 精确匹配检索（带总数）- 保留用于特定场景
   */
  private async exactSearchWithCount(
    filters: SearchFilters,
    limit: number,
    offset: number
  ): Promise<{ memories: Memory[]; total: number }> {
    const where: Prisma.MemoryWhereInput = {};

    if (filters.projectId) {
      where.projectId = filters.projectId;
    }

    if (filters.type) {
      where.type = filters.type;
    }

    if (filters.sessionId) {
      where.sessionId = filters.sessionId;
    }

    if (filters.query) {
      // 将查询字符串按空格拆分为多个关键词，任一匹配即可
      const keywords = filters.query.split(/\s+/).filter(k => k.length > 0);
      if (keywords.length === 1) {
        where.OR = [
          { summary: { contains: keywords[0], mode: 'insensitive' } },
          { fullText: { contains: keywords[0], mode: 'insensitive' } },
        ];
      } else {
        where.OR = keywords.flatMap(keyword => [
          { summary: { contains: keyword, mode: 'insensitive' } },
          { fullText: { contains: keyword, mode: 'insensitive' } },
        ]);
      }
    }

    // 并行执行查询和计数
    const [rows, total] = await Promise.all([
      this.prisma.memory.findMany({
        where,
        orderBy: { timestamp: 'desc' },
        take: limit,
        skip: offset,
      }),
      this.prisma.memory.count({ where }),
    ]);

    return { memories: rows.map(this.rowToMemory), total };
  }

  /**
   * L1: 精确匹配检索
   */
  private async exactSearch(
    filters: SearchFilters,
    limit: number,
    offset: number
  ): Promise<Memory[]> {
    const result = await this.exactSearchWithCount(filters, limit, offset);
    return result.memories;
  }

  /**
   * L2: 全文搜索（PostgreSQL，带总数）
   */
  private async fulltextSearchWithCount(
    filters: SearchFilters,
    limit: number,
    offset: number
  ): Promise<{ memories: Memory[]; total: number }> {
    // 使用PostgreSQL的ILIKE进行简单全文搜索
    const where: Prisma.MemoryWhereInput = {};

    if (filters.projectId) {
      where.projectId = filters.projectId;
    }

    if (filters.type) {
      where.type = filters.type;
    }

    if (filters.sessionId) {
      where.sessionId = filters.sessionId;
    }

    if (filters.query) {
      // 将查询字符串按空格拆分为多个关键词，任一匹配即可
      const keywords = filters.query.split(/\s+/).filter(k => k.length > 0);
      if (keywords.length === 1) {
        where.OR = [
          { summary: { contains: keywords[0], mode: 'insensitive' } },
          { fullText: { contains: keywords[0], mode: 'insensitive' } },
        ];
      } else {
        where.OR = keywords.flatMap(keyword => [
          { summary: { contains: keyword, mode: 'insensitive' } },
          { fullText: { contains: keyword, mode: 'insensitive' } },
        ]);
      }
    }

    // 并行执行查询和计数
    const [rows, total] = await Promise.all([
      this.prisma.memory.findMany({
        where,
        orderBy: { timestamp: 'desc' },
        take: limit,
        skip: offset,
      }),
      this.prisma.memory.count({ where }),
    ]);

    return { memories: rows.map(this.rowToMemory), total };
  }

  /**
   * L2: 全文搜索（PostgreSQL）
   */
  private async fulltextSearch(
    filters: SearchFilters,
    limit: number,
    offset: number
  ): Promise<Memory[]> {
    const result = await this.fulltextSearchWithCount(filters, limit, offset);
    return result.memories;
  }

  /**
   * 获取时间线
   */
  async getTimeline(options: TimelineOptions): Promise<TimelineResult> {
    const where: Prisma.MemoryWhereInput = {
      projectId: options.projectId,
    };

    if (options.type) {
      where.type = options.type;
    }

    if (options.dateRange) {
      where.timestamp = {
        gte: new Date(options.dateRange[0]),
        lte: new Date(options.dateRange[1]),
      };
    }

    const memories = await this.prisma.memory.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: options.limit,
      skip: options.offset,
    });

    const converted = memories.map(this.rowToMemory);

    const entries: TimelineEntry[] = converted.map((memory, index) => ({
      memory,
      prevMemoryId: index > 0 ? converted[index - 1].meta.id : undefined,
      nextMemoryId: index < converted.length - 1 ? converted[index + 1].meta.id : undefined,
    }));

    return {
      entries,
      total: entries.length,
    };
  }

  /**
   * 获取关系链
   * 从 MemoryRelation 表读取关系数据（包括自动关联）
   */
  async getRelations(options: RelationsOptions): Promise<RelationNode> {
    const memory = await this.getMemoryById(options.memoryId);
    if (!memory) {
      throw new Error(`Memory ${options.memoryId} not found`);
    }

    const depth = options.depth || 1;
    const relatedNodes: RelationNode[] = [];

    if (depth > 0) {
      // 从 MemoryRelation 表获取关系（包括自动生成的）
      const relations = await this.prisma.memoryRelation.findMany({
        where: {
          OR: [
            { sourceId: options.memoryId },
            { targetId: options.memoryId },
          ],
        },
      });

      // 提取相关记忆 ID（去重）
      const relatedIds = new Set<string>();
      for (const rel of relations) {
        if (rel.sourceId === options.memoryId) {
          relatedIds.add(rel.targetId);
        } else {
          relatedIds.add(rel.sourceId);
        }
      }

      // 同时检查 Memory 内嵌字段（兼容手动指定的关系）
      if (memory.relations.replaces) {
        memory.relations.replaces.forEach(id => relatedIds.add(id));
      }
      if (memory.relations.relatedTo) {
        memory.relations.relatedTo.forEach(id => relatedIds.add(id));
      }
      if (memory.relations.impacts) {
        memory.relations.impacts.forEach(id => relatedIds.add(id));
      }
      if (memory.relations.derivedFrom) {
        relatedIds.add(memory.relations.derivedFrom);
      }

      for (const relatedId of relatedIds) {
        const relatedMemory = await this.getMemoryById(relatedId);
        if (relatedMemory) {
          // 递归查询关系链
          let nestedRelated: RelationNode[] | undefined = undefined;
          if (depth > 1) {
            const nestedResult = await this.getRelations({
              memoryId: relatedId,
              depth: depth - 1,
            });
            nestedRelated = nestedResult.related;
          }

          relatedNodes.push({
            memory: relatedMemory,
            related: nestedRelated,
          });
        }
      }
    }

    return {
      memory,
      related: relatedNodes.length > 0 ? relatedNodes : undefined,
    };
  }

  /**
   * 根据 ID 获取单个记忆
   */
  async getById(id: string): Promise<Memory | null> {
    const row = await this.prisma.memory.findUnique({
      where: { id },
    });
    return row ? this.rowToMemory(row) : null;
  }

  /**
   * 删除记忆
   */
  async delete(memoryId: string): Promise<{ success: boolean }> {
    try {
      // 先查询 projectId 用于缓存失效
      if (this.cache) {
        const memory = await this.prisma.memory.findUnique({
          where: { id: memoryId },
          select: { projectId: true },
        });
        if (memory) {
          this.cache.invalidateProject(memory.projectId);
        }
      }

      await this.prisma.memory.delete({
        where: { id: memoryId },
      });
      return { success: true };
    } catch (error) {
      return { success: false };
    }
  }

  /**
   * 更新记忆
   */
  async update(memoryId: string, updates: Partial<Memory>): Promise<{ success: boolean }> {
    try {
      const data: Prisma.MemoryUpdateInput = {};

      if (updates.content) {
        if (updates.content.summary) {
          data.summary = updates.content.summary;
        }
        if (updates.content.data !== undefined) {
          data.data = updates.content.data as any;
        }
      }

      if (updates.meta?.tags) {
        data.tags = updates.meta.tags;
      }

      if (updates.relations) {
        if (updates.relations.replaces) {
          data.replaces = updates.relations.replaces;
        }
        if (updates.relations.relatedTo) {
          data.relatedTo = updates.relations.relatedTo;
        }
        if (updates.relations.impacts) {
          data.impacts = updates.relations.impacts;
        }
        if (updates.relations.derivedFrom) {
          data.derivedFrom = updates.relations.derivedFrom;
        }
      }

      if (Object.keys(data).length === 0) {
        return { success: false };
      }

      await this.prisma.memory.update({
        where: { id: memoryId },
        data,
      });

      // 失效相关缓存
      if (this.cache) {
        const memory = await this.prisma.memory.findUnique({
          where: { id: memoryId },
          select: { projectId: true },
        });
        if (memory) {
          this.cache.invalidateProject(memory.projectId);
        }
      }

      return { success: true };
    } catch (error) {
      return { success: false };
    }
  }

  /**
   * 根据ID获取记忆
   */
  private async getMemoryById(id: string): Promise<Memory | null> {
    const row = await this.prisma.memory.findUnique({
      where: { id },
    });
    return row ? this.rowToMemory(row) : null;
  }

  /**
   * 将Prisma行转换为Memory对象
   */
  private rowToMemory(row: any): Memory {
    return {
      meta: {
        id: row.id,
        projectId: row.projectId,
        sessionId: row.sessionId,
        timestamp: row.timestamp.toISOString(),
        type: row.type as MemoryType,
        tags: row.tags || [],
        version: row.version,
      },
      content: {
        summary: row.summary,
        data: (row.data || {}) as Record<string, unknown>,
        // 返回完整原始上下文，保留所有细节
        rawContext: row.context as Record<string, unknown> | undefined,
      },
      relations: {
        replaces: row.replaces || undefined,
        relatedTo: row.relatedTo || undefined,
        impacts: row.impacts || undefined,
        derivedFrom: row.derivedFrom || undefined,
      },
      searchable: {
        keywords: row.keywords || [],
        fullText: row.fullText,
      },
      createdAt: row.createdAt.toISOString(),
      updatedAt: row.updatedAt.toISOString(),
    };
  }

  /**
   * 获取统计信息
   */
  async getStats(projectId?: string): Promise<{
    total: number;
    byType: Record<string, number>;
    byProject: Record<string, number>;
    recentCount: number;
  }> {
    // 构建基础查询条件
    const baseWhere: Prisma.MemoryWhereInput = projectId ? { projectId } : {};

    // 并行执行所有统计查询
    const [totalCount, typeStats, projectStats, recentCount] = await Promise.all([
      // 总数
      this.prisma.memory.count({ where: baseWhere }),

      // 按类型统计
      this.prisma.memory.groupBy({
        by: ['type'],
        where: baseWhere,
        _count: { type: true },
      }),

      // 按项目统计
      this.prisma.memory.groupBy({
        by: ['projectId'],
        where: baseWhere,
        _count: { projectId: true },
      }),

      // 最近 7 天统计
      this.prisma.memory.count({
        where: {
          ...baseWhere,
          timestamp: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          },
        },
      }),
    ]);

    // 转换按类型统计结果
    const byType: Record<string, number> = {};
    typeStats.forEach((row) => {
      byType[row.type] = row._count.type;
    });

    // 转换按项目统计结果
    const byProject: Record<string, number> = {};
    projectStats.forEach((row) => {
      byProject[row.projectId] = row._count.projectId;
    });

    return {
      total: totalCount,
      byType,
      byProject,
      recentCount,
    };
  }

  /**
   * 关闭数据库连接
   */
  async close(): Promise<void> {
    await this.prisma.$disconnect();
  }

  // ========== 项目组管理 ==========

  /**
   * 创建或更新项目组
   */
  async setProjectGroup(group: ProjectGroupConfig): Promise<{ success: boolean }> {
    await this.prisma.projectGroup.upsert({
      where: { name: group.name },
      update: { projects: group.projects },
      create: {
        name: group.name,
        projects: group.projects,
      },
    });
    return { success: true };
  }

  /**
   * 获取项目组
   */
  async getProjectGroup(name: string): Promise<ProjectGroupConfig | null> {
    const row = await this.prisma.projectGroup.findUnique({
      where: { name },
    });

    if (!row) return null;

    return {
      name: row.name,
      projects: row.projects,
    };
  }

  /**
   * 获取项目所属的项目组
   */
  async getProjectGroupByProject(projectId: string): Promise<ProjectGroupConfig | null> {
    const rows = await this.prisma.projectGroup.findMany();

    for (const row of rows) {
      if (row.projects.includes(projectId)) {
        return {
          name: row.name,
          projects: row.projects,
        };
      }
    }

    return null;
  }

  /**
   * 获取所有项目组
   */
  async getAllProjectGroups(): Promise<ProjectGroupConfig[]> {
    const rows = await this.prisma.projectGroup.findMany();

    return rows.map(row => ({
      name: row.name,
      projects: row.projects,
    }));
  }

  /**
   * 删除项目组
   */
  async deleteProjectGroup(name: string): Promise<{ success: boolean }> {
    try {
      await this.prisma.projectGroup.delete({
        where: { name },
      });
      return { success: true };
    } catch {
      return { success: false };
    }
  }

  // ========== 记忆关系管理 ==========

  /**
   * 批量创建记忆关系
   */
  async createRelations(relations: MemoryRelationData[]): Promise<{ success: boolean; count: number }> {
    let count = 0;

    for (const rel of relations) {
      try {
        await this.prisma.memoryRelation.create({
          data: {
            sourceId: rel.sourceId,
            targetId: rel.targetId,
            type: rel.type,
            confidence: rel.confidence,
            isAutoGenerated: rel.isAutoGenerated,
            reason: rel.reason || null,
          },
        });
        count++;
      } catch {
        // 忽略重复关系错误
      }
    }

    return { success: true, count };
  }

  /**
   * 获取记忆的所有关系
   */
  async getMemoryRelations(
    memoryId: string,
    options?: {
      includeAutoGenerated?: boolean;
      type?: 'relatedTo' | 'replaces' | 'impacts';
    }
  ): Promise<MemoryRelationData[]> {
    const where: Prisma.MemoryRelationWhereInput = {
      OR: [
        { sourceId: memoryId },
        { targetId: memoryId },
      ],
    };

    if (options?.includeAutoGenerated === false) {
      where.isAutoGenerated = false;
    }

    if (options?.type) {
      where.type = options.type;
    }

    const rows = await this.prisma.memoryRelation.findMany({
      where,
      orderBy: { createdAt: 'desc' },
    });

    return rows.map(row => ({
      sourceId: row.sourceId,
      targetId: row.targetId,
      type: row.type as 'relatedTo' | 'replaces' | 'impacts',
      confidence: row.confidence,
      isAutoGenerated: row.isAutoGenerated,
      reason: row.reason || '',
    }));
  }

  /**
   * 删除记忆关系
   */
  async deleteRelation(sourceId: string, targetId: string, type?: string): Promise<{ success: boolean }> {
    try {
      const where: Prisma.MemoryRelationWhereInput = {
        sourceId,
        targetId,
      };

      if (type) {
        where.type = type;
      }

      await this.prisma.memoryRelation.deleteMany({ where });
      return { success: true };
    } catch {
      return { success: false };
    }
  }

  /**
   * 搜索候选关联记忆（用于自动关联）
   */
  async searchCandidates(params: {
    keywords: string[];
    projectIds: string[];
    excludeId?: string;
    limit?: number;
  }): Promise<Memory[]> {
    if (params.keywords.length === 0 || params.projectIds.length === 0) {
      return [];
    }

    const limit = params.limit || 50;

    // 构建关键词 OR 条件
    const keywordConditions = params.keywords.flatMap(keyword => [
      { summary: { contains: keyword, mode: 'insensitive' as const } },
      { fullText: { contains: keyword, mode: 'insensitive' as const } },
    ]);

    const where: Prisma.MemoryWhereInput = {
      projectId: { in: params.projectIds },
      OR: keywordConditions,
    };

    if (params.excludeId) {
      where.id = { not: params.excludeId };
    }

    const rows = await this.prisma.memory.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: limit,
    });

    return rows.map(this.rowToMemory);
  }

  /**
   * 自动关联：存储记忆后自动查找并建立关联
   * 基于 tags/keywords 相似度自动建立 relatedTo 关系
   */
  private async autoRelate(memoryId: string, projectId: string, keywords: string[]): Promise<void> {
    // 关键词为空则跳过
    if (keywords.length === 0) {
      return;
    }

    try {
      // 1. 获取新存储的记忆
      const newMemory = await this.getById(memoryId);
      if (!newMemory) {
        return;
      }

      // 2. 获取项目组（支持跨项目关联）
      const projectGroup = await this.getProjectGroupByProject(projectId);
      const projectIds = projectGroup ? projectGroup.projects : [projectId];

      // 3. 搜索候选关联记忆
      const candidates = await this.searchCandidates({
        keywords,
        projectIds,
        excludeId: memoryId,
        limit: 50,
      });

      if (candidates.length === 0) {
        return;
      }

      // 4. 计算相似度并找出相关记忆
      const relatedMemories = findRelatedMemories(newMemory, candidates, {
        threshold: 0.3,
        maxRelations: 10,
      });

      if (relatedMemories.length === 0) {
        return;
      }

      // 5. 生成自动关联关系
      const autoRelations = generateAutoRelations(memoryId, relatedMemories);

      // 6. 写入 MemoryRelation 表
      if (autoRelations.length > 0) {
        await this.createRelations(autoRelations);
      }
    } catch (error) {
      // 自动关联失败不影响主流程，仅打印警告
      console.warn(`自动关联失败 (${memoryId}):`, (error as Error).message);
    }
  }
}
